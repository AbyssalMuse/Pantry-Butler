<?php

//... comments... user i/o is always based on associative arrays
//                all output is an indexed array of associative arrays with column/value pairs
//                all input data arrays are associative with column/value pairs
//                all input clauses are strings, clause only
class DatabaseTools {
	//Variables
	protected $dbName = 'c1510a03proj';
	protected $dbUser = 'c1510a03';
	protected $dbPass = 'c1510a03';
	protected $dbHost = 'localhost';
	protected $error = '';
	
	//Connects to database
	//  Use this before any other functions, for each page
	//Returns true on success, false otherwise
	public function connect() {
		if (!(mysql_connect($this->dbHost, $this->dbUser, $this->dbPass))) {
			$this->error = 'Could not connect to MySQL';
			return(false);
		}
		if (!(mysql_select_db($this->dbName))) {
			$this->error = 'Could not use the database';
			return(false);
		}
		//Successfully connected to database
		return(true);
	}
	
	//Exchanges a query for an array of associative arrays
	//  One associative array for each row in the query (indexed array)
	//  with keys = column names, values = data
	//Use processRowSetSlice for a section of rows
	//... oh, got to the select function and I see where he was going with the single row bit
	//    still not going to use it
	//      hard for caller to tell if they have a nested, multiple-row array or simple, single-row array
	public function processRowSet($rowSet) {
		$resultArray = array();
		mysql_data_seek($rowSet, 0);
		while($row = mysql_fetch_assoc($rowSet)) {
			array_push($resultArray, $row);
		}
		return($resultArray);
	}
	//Exchanges a slice of a query for an array of associative arrays
	//  One associative array for each row in the query (indexed array)
	//  with keys = column names, values = data
	//Define the slice with iStart and length
	public function processRowSetSlice($rowSet, $iStart = 0, $length = 1) {
		$resultArray = array();
		//Error checks
		if (($iStart < 0) || ($length < 1))
			return($resultArray);
		//Process
		mysql_data_seek($rowSet, $iStart);
		for ($i = 0; $i < $length; $i++) {
			array_push($resultArray, $row);
		}
		return($resultArray);
	}
	
	//Query table - all values
	//  Returns an indexed array of associative arrays of column/value pairs
	//  One index for each entity in the table, one pair for each attribute
	//  Returns NULL on error
	//Use Select2 for more options
	public function select($table) {
		$query = "SELECT * FROM $table;";
		$result = mysql_query($query);
		//Error checks
		if (!$result) {
			$this->error = 'Could not query table '.$table.' : '.mysql_error();
			return(NULL);
		}
		//Transform rows into array
		return($this->processRowSet($result));
	}
	
	//Query table with parameters
	//  Returns an indexed array of associative arrays of column/value pairs
	//  One index for each entity in the table, one pair for each attribute
	//  Returns NULL on error
	//Parameters expect strings of content of clause
	//  i.e., "UserName" instead of "SELECT UserName"
	public function select2($table, $fields = "*", $where = "", $order = "") {
		$query = "SELECT $fields FROM $table";
		if ($where != "")
			$query .= " WHERE $where";
		if ($order != "")
			$query .= " ORDER BY $order";
		$query .= ";";
		print $query;
		$result = mysql_query($query);
		//Error checks
		if (!$result) {
			$this->error = 'Could not query table '.$table.' : '.mysql_error();
			return(NULL);
		}
		//Transform rows into array
		return($this->processRowSet($result));
	}
	
	//Update data in table
	//Takes an associative array of column/value pairs
	//Returns true on success, false if errors
	//Where expects a string of content of clause
	//  i.e., "UserName" instead of "SELECT UserName"
	public function update($table, $data, $where = "") {
		$whereClause = "";
		if ($where != "")
			$whereClause = "WHERE $where";
		foreach ($data as $column => $value) {
			$statement = "UPDATE $table SET $column = '$value' $whereClause;";
			if (mysql_query($statement) == false) {
				$this->error = "Could not update table $table: ".mysql_error();
				return(false);
			}
		}
		return(true);
	}
	
	//Add a new entity to table
	//Takes an associative array of column/value pairs
	//Returns index of new row on success, false on error
	//... returns the autogenerated id, if there is one
	//    so is there a function that returns the row number... because there's always one of those...
	public function insert($table, $data) {
		//Create list of columns and values as individual strings
		$columns = "";
		$values = "";
		foreach ($data as $column => $value) {
			$columns .= "$column, ";
			$values .= "$value, ";
		}
		$columns = chop($columns, ", ");
		$values = chop($values, ", ");
		//Query
		$statement = "INSERT INTO $table($columns) VALUES($values)";
		if (mysql_query($statement) == false) {
			$this->error = "Could not insert into table $table: ".mysql_error();
			return(false);
		}
		return(mysql_insert_id);
	}
	
	//Delete an entity from table
	//Where expects a string of content of clause
	//  i.e., "UserName" instead of "SELECT UserName"
	//  Ignores empty strings, use TRUNCATE instead
	//Returns true on success, false otherwise
	//  Note that "No matching record(s)" is a success
	public function delete($table, $where) {
		//Error check
		if ($where == "") {
			$this->error = "Delete from error - empty Where clause";
			$this->error .= "\nUse TRUNCATE to delete all table data, not DELETE";
			return(false);
		}
		//Process
		$statement = "DELETE FROM $table WHERE $where";
		if (mysql_query($statement) == false) {
			$this->error = "Could not delete from table $table: ".mysql_error();
			return(false);
		}
		return(true);
	}
	
	//Returns most recent error message
	public function getError() {
		return($this->error);
	}
}

?>
