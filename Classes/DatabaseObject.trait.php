<?php
/*  DatabaseObject
 *  Abstract class that mirrors a database table
 *  Represents an existing entity/object in the table
 *    Cannot be used as a scratch object, cannot be used after deletion
 *  Singleton design - changing a table variable will be reflected in other php objects of the same entity
 *    Will also automatically be updated to table
 *  Single table only
 *  Assumes ID is a single field, autogenerated
 *    As of now, cannot handle composite primary keys or non-autogenerated IDs
 *  Requirements:
 *      Set static variables $tableName and $idName (outside of class scope)
 *	Create private variables for each column in table, case sensitive
 *	Create validate... functions for each column in table, again case sensitive
 *  Usage:
 *	Use one of the three constructors to create
 *	  Either from the database, from a query result, or a new entity from data
 *	Only use variables from outside of class
 *        Variables are actually public, see Issues
 *  Others:
 *      Can prevent createNew by overriding in class with an empty function
 *  
 *  Issues: Nothing I run into here, but this doesn't generalize perfectly...
 *      The __get and __set magic methods expose all variables, making them all public
 *        Solution: check for accessor/mutator methods first, then update database, then call those methods
 *                  comes from Stack Overflow suggestion (http://stackoverflow.com/questions/9803434/php-visibility-with-magic-methods-get-set)
 *      The __get and __set magic methods aren't called if the variable is public
 *        From tests I don't think this is true, but would require all variables to be private or undefined
 *      The __get and __set magic methods aren't called from inside class
 *        Solution: inform users, provide a Sync() to easily update database
 *      Fetch_Object still creates new instance
 *        Solution? Maybe handle instance-retrival in constructor?
 */
 
 /* To do
 	Remove all prints
 	... raise exceptions instead? only print for administrator?
 	Combine traits with PDO
 	Validation check - require functions
 	Query by multiple ids? set field/value?
 	... already have Where clause function, but those would hide info better
 	Multiple table object? Take query and array of tables to know which should be which?
 	... or would it be easier to create a complex object with multiple database objects from different tables?
 	... would also allow that class to not follow singleton design, so it can have own variables
 	... in usage so far, requires class composition - a class with the step/stepingredient/etc. and functions to acces information inside of it
 	Many database sets aren't actually overrides, but user created content
 	  So changing a RecipeStep should create a new object (if using default/master user/null) with UserID
 	  So that requires taking in UserID at some point...
 	Handle removal from memory? Instances array always keeps one reference to the object alive, so does that prevent garbage collection?
 	  ... all database interactions happen through this object, so it should be okay if I keep the same reference for days on end
 	      no, it's not, because it eats memory, would end up storing the database here (if the program never resets)
 	      I know the instances array is kept between ajax calls, so the program scope is larger than <?php ?>
 	  ... possible solution: keep a counter, +1 on construct, -1 on destruct
 	      solution 2: I've never had luck with counters, so maybe keep a timer 
 	                  and reset everything for each person or every few hours or low memory situations
 	Test whether references are shared between sessions/users, so one cuisine reference is used by everyone
 */
 
 /* Tests so far
 	Set works, flows through to database
 	References works, if I query same row twice I get back the same php object reference
 	AJAX works, if one page uses another as AJAX, and makes the same query twice, like AllCuisines, gets the same references each time
 	  ??? maybe I just got lucky though? maybe the instances array kept the memory addresses but they were really undefined the second time around
 	      and like C++ the only reason I got back the same cuisine objects was because nothing had overwritten them yet
 	      but if the objects are lost between <?php ?> then why did the Recipe object keep it's instances array? oh, because it's static
 */
 
trait DatabaseObject {
	//Interface/Contract
	
	//Variables
	//Set these following your class definition - as in, global, outside of the class, space
	public static $tableName; 	//Case sensitive
	//public static $idName; 		//Case sensitive, single column only, Primary Key, not secondary
	//Declare your variables, make sure to match the column names exactly (case sensitive)
	//Variables can be public or private
	//Variables should not be set to defaults - they will be overwritten by database query
	
	//create only if you need variable default values
	//  if you need constants then set them in the database
	/*
	public static function defaultValues() {
		$data = array("field" => "value", "field" => "value");
		return($data);	
	}
	*/
	
	//Constructors
	//No direct construction
	//... needs to be done in sub-classes, because composite needs to override it
	private function __construct() {}
	private function __clone() {}
	private function __wakeup() {}
	/*
	   Can either create a new database entity, query the database, or use a result from an old query
	   Can either create a single record (first three functions) or multiple records (last two functions)
	*/
	//Query database with primary key ID
	abstract public static function createFromQuery();
	//Use old query, pass in entire result
	//Query result rows need to match the table's columns
	//If iRow not set, then will take row at current cursor
	//... test incomplete row, but still all from same table
	//... make this more flexible
	public static function createFromResult($result, $iRow = -1) {
		//Check that all fields belong to table
		for ($i = 0; $i < mysql_num_fields($result); $i++) {
			if (mysql_field_table($result, $i) != __Class__) {
				return(null);
			}
		}
		if ($iRow >= 0)
			mysql_data_seek($result, $iRow);
		return(self::getInstance($result));
	}
	//Use column/value pairs to create/insert a new entity
	//Takes an associative array
	//Must contain all NOT NULL constrained columns, but doesn't require others
	//Can include auto-generated ID field
	//  Works just like database query - if already used then won't be created
	//Values are validated with the appropriate function
	//... more flexible with ID column - just ignore it if passed in?
	//    if I'm going to test, I might as well use that ID
	//    could separate into two functions, but lose test then and rely on user
	abstract public static function createNew();
	//Multiple object constructors
	//Query database with a WHERE clause
	//Returns an array of objects if there are any
	//  Returns null if there are no matching records
	public static function createSliceFromQuery($whereClause = "", $orderClause = "") {
		global $dbo;
		//... check the id is the same type as idName
		//    or just let the query die
		$query = "SELECT * FROM ".self::$tableName;
		if ($whereClause != "")
			$query .= " WHERE $whereClause";
		if ($orderClause != "") {
			$query .= " ORDER BY $orderClause";
		}
		$query .= ";";
		$result = mysql_query($query);
		if ($result == null)
			return(null);
		if (mysql_num_rows($result) == 0)
			return(null);
		$slice = array();
		for ($i = 0; $i < mysql_num_rows($result); $i++) {
			array_push($slice, self::getInstance($result));
		}
		return($slice);
	}
	//Use old query, pass in entire result
	//Query result rows need to match the table's columns
	//Returns an array of objects
	//  Returns null for invalid parameters (iStart beyond array size, length zero/negative)
	public static function createSliceFromResult($result, $iStart = 0, $length = 1) {
		//Check that all fields belong to table
		for ($i = 0; $i < mysql_num_fields($result); $i++) {
			if (mysql_field_table($result, $i) != __Class__) {
				return(null);
			}
		}
		//Create slice
		$slice = array();
		mysql_data_seek($result, $iStart);
		$iStop = $iStart + $length;
		if ($iStop > mysql_num_rows($result))
			$iStop = mysql_num_rows($result);
		for ($i = $iStart; $i < $iStop; $i++) {
			array_push($slice, self::getInstance($result));
		}
		return($slice);
	}
	
	//retrieve parent objects
	//... requires all variable names to prefix underscore
	//... write it out later, if time
	//    better way would be use foreign key to figure out table
	//    not sure I want to store the retrieved DBO on the original DBO, unless I can prevent JSON from encoding it
	//see RecipeOverview for usage example
	/*
	public function getLinkedDBO($columnName, $tableName) {
		$varName = "_".$columnName;
		if (!isset($this->$varName)) {
			if ($this->$columnName != null) {
				$this->$varName = $tableName::createFromQuery($this->$columnName);
			} else
				$this->$varName = null;
			}
		} else {
			return ($this->$varName);
		}
	}
	*/
	
	//Helper functions (you see nothing)
	//Variables
	private static $instances; 	//List of entities that have already been queried
	
	//Return instance if one already exists for that database entity
	//  Otherwise return a new instance
	//... should actually be private in sub-classes
	abstract public static function getInstance();
	
	//... can a particular variable overwrite this set, in case it wants to prevent changes
	//    or could tell caller to override __set, catch whatever is needed
	//abstract public function __set();
	//... what should this return with errors
	abstract public function multiSet();
	//... only necessary for database/static check
	//... what should it return? what can't be returned by database? not null...
	//    or should I throw an error
	//abstract public function __get();
	
	//    delete from database
	//    delete all objects from further use
	//      require destruction? no, because there can be other copies around
	//        also because destruction is out-of-scope close down, happens often and frees memory, not signal that object can never be used again
	//      semi-singleton design, pass out reference if already SELECTed from database
	abstract public function delete();
	
	//Validate each variable passed in
	//data should be column/value pairs
	public static function validate($data) {
		foreach ($data as $name => $value) {
			if (method_exists(__Class__, "validate".$name) === false)
				continue; //Should require validation functions, but time is short
				//return(false);
			if (self::{"validate".$name}($value) === false)
				return(false);
		}
		return(true);
	}
}

//use autogen instead if not going to include id column
trait DatabaseObjectSimple {
	//Don't need "DOS::createFromQuery insteadof DO"
	use DatabaseObject;
	
	public static $idName;
	
	//Query database with primary key ID
	public static function createFromQuery($id) {
		//Is instance already available?
		if (!empty(self::$instances[$id])) //Use empty, not isset, because $instance can be null
			return(self::$instances[$id]);
		global $dbo;
		//... check the id is the same type as idName
		//    or just let the query die
		$query = "SELECT * FROM ".self::$tableName." WHERE ".self::$idName." = '$id'";
		$result = mysql_query($query);
		if ($result == null) //Returns null for bad query? I thought I had some null returns...
			return(null);
		if (mysql_num_rows($result) == 0) //Seriously?!? doesn't return null, but 0 rows for empty set
			return(null);
		if (mysql_num_rows($result) > 1)
			return(null);
		return(self::getInstance($result));
	}
	
	public static function createNew($id, $data = null) {
		//... test if already created, instance available - no, assuming this should be brand new
		//Validate data - checks values and names
		//Doesn't check if values are unique, let INSERT check that
		//... might want separate new entity validation rules to allow complex rules
		if ($data != null) {
			if (self::validate($data) === false)
				return(null);
		}
		if (self::validate(array(self::$idName => $id)) === false)
			return(null);
		//Create default data
		if (method_exists(__Class__, 'defaultValues')) {
			$defaults = self::defaultValues();
			$data = array_merge($defaults, $data); //Defaults first so input data will override defaults
		}
		//Create list of columns and values as individual strings
		$columns = self::$idName.", ";
		$values = "'".$id."', ";
		if ($data != null) {
			foreach ($data as $column => $value) {
				$columns .= "$column, ";
				$values .= "'$value', ";
			}
		}
		$columns = chop($columns, ", ");
		$values = chop($values, ", ");
		//Insert
		$statement = "INSERT INTO ".self::$tableName."($columns) VALUES($values)";
		if (mysql_query($statement) == false) {
			return(null);
		}
		//Create
		return(self::createFromQuery($id));
	}
	
	
	private static function getInstance($result) {
		$newThis = mysql_fetch_object($result, __Class__); //Faster than using mysql_result to fetch ID
		if ($newThis == null) {
			print "Fetch error ".mysql_error()."<br>";
			var_dump($result);
			print "<br>";
			return(null);
		} else if (empty(self::$instances[$newThis->{self::$idName}])) {
			self::$instances[$newThis->{self::$idName}] = $newThis;
			return($newThis);
		} else {
			return(self::$instances[$newThis->{self::$idName}]);
		}
	}
	
	public function __set($name, $value) {
		global $dbo;
		//... don't allow id to be changed?
		//    check that there's no other id like it first
		//    only if the field is autogenerated?
		//Entity exists in table?
		if (!isset(self::$instances[$this->{self::$idName}]))
			return(null);
		//Validate data - checks values and names
		if (self::validate(array($name => $value)) === false)
			return(null);
		$dbo->update(self::$tableName, array($name => $value), self::$idName." = '{$this->{self::$idName}}'");
		$this->$name = $value;
	}
	
	public function multiSet($data) {
		//Entity exists in table?
		if (!isset(self::$instances[$this->{self::$idName}]))
			return(null);
		//Validate data - checks values and names
		if (self::validate($data) === false)
			return(null);
		//Set clause
		$setClause = "";
		foreach ($data as $name => $value) {
			$setClause .= "$name = '$value', ";
		}
		$setClause = chop($setClause, ", ");
		//Update - database, then object (if successful)
		global $dbo;
		$query = "UPDATE ".self::$tableName." SET $setClause WHERE ".self::$idName." = '{$this->{self::$idName}}';";
		if (mysql_query($query)) {
			foreach ($data as $name => $value) {
				$this->$name = $value;
			}
		}
	}

	public function __get($name) {
		//Entity exists in table?
		if (isset(self::$instances[$this->{self::$idName}])) {
			return($this->$name);
		} else {
			return(null);
		}
	}
	
	public function delete() {
		//Entity still exists in table?
		if (!isset(self::$instances[$this->{self::$idName}]))
			return(null);
		//Delete
		$query = "DELETE FROM ".self::$tableName." WHERE ".self::$idName." = '{$this->{self::$idName}}';";
		if (mysql_query($query)) {
			print "Delete successful (".mysql_affected_rows().")";
			self::$instances[$this->{self::$idName}] = null;
			var_dump(self::$instances);
		}
		else print "Couldn't delete ".mysql_error();
	}
}

trait DatabaseObjectAutoGen {
	use DatabaseObjectSimple {
		DatabaseObjectAutoGen::createNew insteadof DatabaseObjectSimple;
	}
	
	public static function createNew($data) {
		//... test if already created, instance available - no, assuming this should be brand new
		//Validate data - checks values and names
		//Doesn't check if values are unique, let INSERT check that
		//... might want separate new entity validation rules to allow complex rules
		if (self::validate($data) === false)
			return(null);
		//Create default data
		if (method_exists(__Class__, 'defaultValues')) {
			$defaults = self::defaultValues();
			$data = array_merge($defaults, $data); //Defaults first so input data will override defaults
		}
		//Create list of columns and values as individual strings
		$columns = "";
		$values = "";
		foreach ($data as $column => $value) {
			$columns .= "$column, ";
			$values .= "'$value', ";
		}
		$columns = chop($columns, ", ");
		$values = chop($values, ", ");
		//Insert
		$statement = "INSERT INTO ".self::$tableName."($columns) VALUES($values)";
		if (mysql_query($statement) == false) {
			return(null);
		}
		//Create
		if (empty($data[self::$idName]))
			return(self::createFromQuery(mysql_insert_id()));
		else
			return(self::createFromQuery($data[self::$idName]));
	}
}

trait DatabaseObjectComposite {
	use DatabaseObject;
	
	public static $idFields;
	
	//Query database with array of primary keys
	//  Order must match $idFields, must be associative array with their names, case sensitive
	public static function createFromQuery($ids) {
		//Is instance already available?
		if (!empty(self::$instances[json_encode($ids)])) //Use empty, not isset, because $instance can be null
			return(self::$instances[json_encode($ids)]);
		global $dbo;
		//Where clause
		//... check the id is the same type as idName()
		//    or just let the query die
		$query = "SELECT * FROM ".self::$tableName." WHERE ".self::generateWhereClause($ids).";";
		$result = mysql_query($query);
		if ($result == null)
			return(null);
		if (mysql_num_rows($result) > 1)
			return(null);
		return(self::getInstance($result));
	}
	
	//handle ids separately in case I want to add instance check (with json) later
	public static function createNew($ids, $data = null) {
		//... test if already created, instance available - no, assuming this should be brand new
		//Validate data - checks values and names
		//Doesn't check if values are unique, let INSERT check that
		//... might want separate new entity validation rules to allow complex rules
		if ($data != null) {
			if (self::validate($data) === false)
				return(null);
		}
		if (self::validate($ids) === false)
			return(null);
		//Create default data
		if (method_exists(__Class__, 'defaultValues')) {
			$defaults = self::defaultValues();
			$data = array_merge($defaults, $data); //Defaults first so input data will override defaults
		}
		//Create list of columns and values as individual strings
		$columns = "";
		$values = "";
		foreach ($ids as $column => $value) {
			$columns .= "$column, ";
			$values .= "'$value', ";
		}
		if ($data != null) {
			foreach ($data as $column => $value) {
				$columns .= "$column, ";
				$values .= "'$value', ";
			}
		}
		$columns = chop($columns, ", ");
		$values = chop($values, ", ");
		//Insert
		$statement = "INSERT INTO ".self::$tableName."($columns) VALUES($values)";
		if (mysql_query($statement) == false) {
			return(null);
		}
		//Create
		return(self::createFromQuery($ids));
	}
	
	
	private static function getInstance($result) {
		$newThis = mysql_fetch_object($result, __Class__); //Faster than using mysql_result to fetch ID
		if ($newThis == null) {
			print "Fetch error ".mysql_error()."<br>";
			var_dump(mysql_fetch_row($result));
			print "<br>";
			return(null);
		}
		//Create id string with json
		$ids = array();
		
		//
		if (empty(self::$instances[$newThis->idName()])) {
			self::$instances[$newThis->idName()] = $newThis;
			return($newThis);
		} else {
			return(self::$instances[$newThis->idName()]);
		}
	}
	
	public function __set($name, $value) {
		print "<br>Setting $name to $value<br>";
		//... don't allow id to be changed?
		//    check that there's no other id like it first
		//    only if the field is autogenerated?
		//Entity exists in table?
		if (!isset(self::$instances[$this->idName()]))
			return(null);
		print "Still setting<br>";
		//Validate data - checks values and names
		if (self::validate(array($name => $value)) === false)
			return(null);
		print "Still setting<br>";
		//Update - database, then object (if successful)
		global $dbo;
		$query = "UPDATE ".self::$tableName." SET $name = '$value' WHERE ".self::generateWhereClause($this->extractIDs()).";";
		if (mysql_query($query)) {
			$this->$name = $value;
		}
		print "Tried to query $query<br>".mysql_error()."<br>";
	}
	
	public function multiSet($data) {
		//Entity exists in table?
		if (!isset(self::$instances[$this->idName()]))
			return(null);
		//Validate data - checks values and names
		if (self::validate($data) === false)
			return(null);
		//Set clause
		$setClause = "";
		foreach ($data as $name => $value) {
			$setClause .= "$name = '$value', ";
		}
		$setClause = chop($setClause, ", ");
		//Update - database, then object (if successful)
		global $dbo;
		$query = "UPDATE ".self::$tableName." SET $setClause WHERE ".self::generateWhereClause($this->extractIDs()).";";
		if (mysql_query($query)) {
			foreach ($data as $name => $value) {
				$this->$name = $value;
			}
		}
	}

	public function __get($name) {
		//Entity exists in table?
		if (isset(self::$instances[$this->idName()])) {
			return($this->$name);
		} else {
			return(null);
		}
	}
	
	public function delete() {
		//Entity still exists in table?
		if (!isset(self::$instances[$this->idName()]))
			return(null);
		//Delete
		$query = "DELETE FROM ".self::$tableName." WHERE ".self::generateWhereClause($this->extractIDs()).";";
		if (mysql_query($query)) {
			print "Delete successful (".mysql_affected_rows().")";
			self::$instances[$this->idName()] = null;
			var_dump(self::$instances);
		}
		else print "Couldn't delete ".mysql_error();
	}
	
	//private $idName; //... no, because the extra field will be printed out when passing to javascript
	private function idName() {
		return(json_encode($this->extractIDs()));
	}
	//returns an associative array
	private function extractIDs() {
		$ids = array();
		foreach (self::$idFields as $fieldName) {
			$ids[$fieldName] = $this->$fieldName;
		}
		return($ids);
	}
	private static function generateWhereClause($ids) {
		$whereClause = "";
		foreach ($ids as $column => $value) {
			$whereClause .= "$column = '$value' AND ";
		}
		$whereClause = substr($whereClause, 0, -strlen(" AND "));
		return($whereClause);
	}
}
?>
